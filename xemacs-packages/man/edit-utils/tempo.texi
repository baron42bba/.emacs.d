\input texinfo        @c -*-texinfo-*-
@c %**start of header
@setfilename tempo.info
@settitle Tempo manual
@setchapternewpage odd
@iftex
@afourpaper
@end iftex
@c %**end of header

@set EDITION 0.0(prerelease)
@set VERSION 1.2.3
@set UPDATED 8 June 1995
@set UPDATED-MONTH June 1995

@ifinfo
This is Edition @value{EDITION},
last updated @value{UPDATED},
of @cite{the Tempo manual},
for @code{tempo.el} version @value{VERSION}.

Copyright @copyright{} 1995 David Kågedal
     
Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.
     
@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries a copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).
     
@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
section entitled ``Copying''is included exactly as in the original, and
provided that the entire resulting derived work is distributed under the
terms of a permission notice identical to this one.
     
Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.
@end ifinfo

@titlepage
@title Tempo
@subtitle A template package for GNU Emacs
@subtitle Edition @value{EDITION}
@subtitle @value{UPDATED-MONTH}
@author David K@aa{}gedal <davidk@@lysator.liu.se>

@page
@vskip 0pt plus 1filll

Copyright @copyright{} 1995 David K@aa{}gedal

This manual is availible on anonymous @code{ftp} from
@file{ftp.lysator.liu.se}, in the directory @file{/pub/emacs}.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.
     
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
section entitled ``Copying'' is included exactly as in the original, and
provided that the entire resulting derived work is distributed under the
terms of a permission notice identical to this one.
     
Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.
@end titlepage

@ifinfo
@node Top, Overview, (dir), (dir)
@top Tempo

This is Edition @value{EDITION}, last updated @value{UPDATED}, of the
manual for @code{tempo.el} version @value{VERSION}.

Tempo is a template writing package for GNU Emacs.

@menu
* Overview::                    An overview of tempo
* Templates::                   Templates
* Options::                     Controlling tempo behaviour
* The mark list::               The mark list
* The save list::               The save list
* Adding tempo::                Adding tempo support
* Concept index::               Concept index
* Function index::              Function index
* Variable index::              Variable index
* Copying::                     The terms of this distribution

 --- The Detailed Node Listing ---

Overview

* A short example::             Example
* Basics::                      Tempo basics
* Tags overview::               Tag lists and automatic completion

Templates

* Syntax::                      Template syntax
* Elements::                    Template elements
* Defining your own elements::  Defining your own elements
@end menu

@end ifinfo

@node Overview, Templates, Top, Top
@chapter Overview

Tempo is a package that provides writers and users of Emacs editing
modes with functions for creating and inserting templates into an Emacs
buffer in a convenient way. The template insertion commands can be bound
to keys or can be automatically expanded from words written in the
buffer.

@menu
* A short example::             Example
* Basics::                      Tempo basics
* Tags overview::               Tag lists and automatic completion
@end menu

@node A short example, Basics, Overview, Overview
@comment  node-name,  next,  previous,  up
@section A short example

A good way to get a general idea of what @code{tempo} is about is
through an introductory example. The follwoing short example of a
@code{tempo} template builds a template for inserting a for loop in a C
program.

@lisp
(tempo-define-template "c-for"
                       '("for ("
                         (p "Initialization: ") ","
                         (p "Increment: ") ","
                         (p "End condition: ") " @{" n>
                         r n>
                         "@}" > %))
@end lisp

This creates a command @code{tempo-template-c-for} which, when executed,
inserts the following at the point:

@example
for (@point{},,) @{
    
@}
@end example

The point is placed at the @point{}, which is not included in the
text. The command @kbd{M-x tempo-forward-mark} will, at this point, move
the point to after the first comma. Successive executions will move the
point to after the second comma, to the second line and to after the
closing brace. In a mode customized for tempo, @code{tempo-forward-mark}
will of course be bound to some convenient keystroke combination.

If the variable @code{tempo-interactive} was set to non-nil, the result
would have been a little different. Instead of inserting nothing inside
the parenthesis, the user would be prompted for the text to be written
in the three positions, with the prompt strings @samp{Initialization:},
@samp{Increment:} and @samp{End condition:}, respectively, and the point
would be placed on the second line, properly indented.

Also, if there was a currently active region (@pxref{Mark,Regions,The
Mark and the Region,emacs,the GNU Emacs Manual}), and the template
command was used with a prefix argument (such as @kbd{C-u M-x
tempo-template-c-for}) the for loop would be inserted around the region,
so that the contents of the region would be placed between the the
opening and closing braces.

@node Basics, Tags overview, A short example, Overview
@section Tempo basics

The most inportant function in tempo is @code{tempo-define-template},
which defines a template, together with a function to insert
it. @xref{Syntax}, for a complete description of this function.

A simple definition has the form

@lisp
(tempo-define-template @var{name} @var{elements})
@end lisp

When this is evaluated, the variable @code{tempo-template-@var{name}} is
bound to @var{elements}, and the function @code{tempo-template-@var{name}}
is a command that will insert the template when invoked.

The @var{elements} is supplied as a list whose elements have different
meanings. Strings are simply inserted and lisp expressions are evaluated
to strings. There are also some symbols with special meanings, such as:

@table @code
@item p
@itemx (p @var{prompt} [@var{name}])
The symbol @code{p} marks a ``hot spot'' in a template. When this is
encountered, the current position of the point is saved as a marker and
saved on the @code{tempo-marks} list. These marks can later easily be
jumped to with the functions @code{tempo-forward-mark} and
@code{tempo-backward-mark}.

If the form @code{(p @var{prompt})} is used, and the variable
@code{tempo-interactive} is non-@code{nil}, @var{prompt} is used to
prompt the user for a string in the minibuffer. If
@code{tempo-interactive} is @code{nil}, it works just like a single
@code{p}.

@item r
@itemx (r @var{prompt})
This works very much like @code{p}, but when the template was invoked
with a prefix (as with @kbd{C-u @var{template-cmd}}) and a region is
active, the template will be wrapped around the region, so that the text
of the region is placed where the @code{r} element is.

@item >
A greater-than sign in a template means that the current line should be
indented according to the current mode. The function @code{indent-line}
is called, which usually gives the desired result. not that often it is
advisable to insert the @code{>} after the text to be put on the line,
to help the indention function.

@end table

There are many more thing you can put in a template, but the above are
some of the more essential. @xref{Elements}, for a full description of the
possible template elements.

@node Tags overview,  , Basics, Overview
@section Tag lists and automatic completion

If you supply a third argument @var{tag} to
@code{tempo-define-template}, it can be used as an abbrevation for the
template. If you gave the C for-loop in the example above a third
argument @code{"for"}, you could use the completion capabilities in
tempo. If you write in a buffer (with the point at @point{}):

@example
for@point{}
@end example

and type @kbd{M-x tempo-complete-tag}, the string @samp{foo} would be
replaced by the for-loop template. For this to be really useful,
@code{tempo-complete-tag} should be bound to a convenient keystroke. But
there is more power in this command. If you have defined a template with
the tag @samp{procedure} you can hit @kbd{M-x tempo-complete-tag} as
soon as you have written a unique prefix of the word. For example

@example
proc@point{}
@end example

could expand to

@example
procedure @point{}();
begin

end;
@end example

when you type @kbd{M-x tempo-complete-tag} had you defined a Pascal
@code{procedure} template with the tag @samp{procedure}. If there is no
unique match, @code{tempo-complete-tag} will complete the tag as much as
possible, and show a buffer with the possible completions. You can then
type another character, which will hopefully make it unique and press
@kbd{M-x tempo-complete-tag} again.

Unfortunaly, there is no good way to use the mouse in the completion
buffer, although it claims to be so.

@node Templates, Options, Overview, Top
@chapter Templates

@iftex
This chapter describes the syntax and semantics of templates defined by
@code{tempo-define-template}. The first section deals with the syntax of
the function itself, while the second section describes the different
template elements.
@end iftex

@ifinfo
This node describes the syntax and semantics of templates defined by
@code{tempo-define-template}. The first part deals with the syntax of
the function itself, while the second part describes the different
template elements.
@end ifinfo

@menu
* Syntax::                      Template syntax
* Elements::                    Template elements
* Defining your own elements::  Defining your own elements
@end menu

@node Syntax, Elements, Templates, Templates
@section Template syntax
@cindex Defining new templates
@cindex Writing templates
@cindex Templates

Templates are defined with the function @code{tempo-define-tempalate}.

@defun tempo-define-template name elements [tag documentation [taglist]]]
Define a template named @code{tempo-template-@var{name}}.

This function creates a template and binds it to a new variable named
@code{tempo-template-@var{name}}. It also creates a new command under
the same name. This command expands the template at the current point,
when invoked.

The parameter @var{elements} is a list of template elements. The
possible elements are described in @ref{Elements}.

If a @var{tag} is supplied, it must be a string which is placed in
@var{taglist} or @code{tempo-tags}. This string is used for automatic
completion. When @code{tempo-complete-tag} is called and @var{tag} is
matched, the template template defined with @var{tag} is
inserted. (@pxref{Tags overview} for more information on tags and tag
lists)
@end defun

@node Elements, Defining your own elements, Syntax, Templates
@section Template elements
@cindex Elements
@cindex Template elements

These are the predefined elements you can use in a template definition:

@table @code
@item @var{STRING}
A string in a template is first run through the string preprocessors in
@code{tempo-insert-string-functions} and the result is inserted.

@item p
This denotes an ``interesting'' position in the template. When the
template is expanded, this position is remembered with a mark on the
tempo-marks list. @xref{The mark list}.

@item r
This works in a similar way to the above @code{p} element, but if the
template command is given a prefix command, the current region is placed
here. This means that the preceding part of the template is expanded
before the region, and the rest is expanded after. There can be only one
@code{r} in a template. If @code{transient-mark-mode} is active
(@pxref{Mark,Regions,The Mark and the Region,emacs,the GNU Emacs
Manual}) the current region is used and the prefix argument is ignored.

If the variable @code{tempo-insert-region} is non-nil, the behaviour of
the @code{r} element is reversed.

@item (p @var{prompt} [@var{name} [@var{noinsert}]])
@itemx (P @var{prompt} [@var{name} [@var{noinsert}]])
@itemx (r @var{prompt} [@var{name} [@var{noinsert}]])
If the variable @code{tempo-interactive} is nil, the elements @code{(p
@dots{}))} and @code{(P @dots{})} work exactly like a single @code{p},
and @code{(r @dots{})} works like a single @code{r}.

But, if you set @code{tempo-interactive} to @code{t} the user is
prompted for a string to insert when the template is expanded. The
prompt is taken from the @code{prompt} parameter. The element @code{(P
@dots{})} works like @code{(p @dots{})} with the exception that
@code{tempo-interactive} is forced to @code{t}, which means that the
user will always (almost always, see below) be prompted.

If you provide a @var{name} to any of these, and interactive prompting
is taking place, the resulting string is saved in a local list so it can
be inserted again later with the @code{(s @dots{})} element. @xref{The
save list}, for more detailed information.

As a special case, if the save list already contains something under
@var{name}, it is used directly, and no prompting is done, even with a
@code{(P @dots{})} element.

The third argument, @var{noinsert}, disables insertion of text. If
@code{tempo-interactive} it non-@code{nil}, and a @var{name} has been
provided, normally a string is read through the minibuffer and then
inserted and saved. When @var{noinsert} is non-@code{nil}, nothing is
inserted, and the text is only saved for later.

@ignore
@item (v @var{name} @var{prompt})
This element simply prompts for a string and saves it as @var{name}. The
prompt is taken from @var{prompt}. Nothing is inserted.
@end ignore

Stylistic conventions (invented by me) dictates that these elements
should be placed as early as possible in template definitions.

@item r>
This element works like @code{r}, but it also indents the region it is
expanded around.

@item (s @var{name})
This looks up @var{name} in the save list and inserts what it
finds. Note that if it finds a string, it is not run through the string
preprocessors.

@item &
An ampersand inserts a newline if there are characters other than
whitespace before the current point on the line. Otherwise it does
nothing. This means that it makes sure that the following text always
starts a new line, possibly with some leading whitespace.

@item %
A percent sign inserts a newline it there are characters other than
whitespace after the current point on the line. Otherwise it does
nothing.

@item n
Simply inserts a newline character.

@item >
This does not insert any text. Instead it indents the line according to
the major mode, by calling @code{indent-according-to-mode}. Note that in
order to get best results, you often should place this after the text
you want to place on the line, as this could affect the indentation.

@item n>
Inserts a newline and indents line. It is the same as a @code{n}
followed by a @code{>}.

@item o
Works like @code{%}, but leaves the point on the first line. Note that
this can cause great confusion if you are not careful. If the @code{o}
is the first element in a template which is inserted at the beginning of
a line, strange things happen. This is due to odd behaviour in
@code{open-line}.

@item nil
A @code{nil} element is simply igonred. That means that a lisp
expression (see below) that returns nil does not insert anything.

@item (l @var{element1} @var{element2}@dots{})
This element is most useful as a return value from a lisp expression
(see below). It inserts the elements using the same rules as all
template elements.

@item @i{Anything else}
All unrecognized elements are checked to see if it is a user-defined
elemet. @xref{Defining your own elements}. If isn't, it is assumed to be
a lisp expression and is evaluated in a normal fashion. The result from
such an expression is taken as a template element an is inserted
according to the usual rules. If you don't want to insert anything, make
your expression return @code{nil}. If you want to insert more than one
element, use the @code{(l @var{element1} @var{element2}@dots{})}
element.

@end table

@node Defining your own elements,  , Elements, Templates
@section Defining your own elements
@cindex Defining elements
@cindex User-defined elements
@cindex Adding elements

The variable @code{tempo-user-elements} contains a list of functions to
call when an unrecognized element is found.

@defvar tempo-user-elements
A list of functions. When @code{tempo-insert} is called with an element
it doesn't recognize, it checks this list by calling each function with
the element as the single argument. A function in this list should take
a single element as argument and return @code{nil} for elements it
doesn't recognize. If it does recognize an element, it should return
another element to be inserted, e.g. a string. If the function wants to
return an authorative @code{nil}, it could return either @code{""} or
@code{(l)}.
@end defvar

Do not use any one-charachter tags for your own elements. These are
reserved for future tempo enhancements.

@node Options, The mark list, Templates, Top
@chapter Controlling tempo behaviour
@cindex Customization
@cindex User options

There are some options available for the end user of tempo templates.

@defopt tempo-interactive
Controls whether templates should prompt the user for strings to insert
via the minibuffer or let the user edit them in place. This affects the
behaviour of the template elements @code{(p @dots{})} and @code{(r
@dots{})}.
@end defopt

@defopt tempo-insert-region
Controls the behaviour of the @code{r}, @code{r>} and @code{(r @dots{})}
tags. If this variable is @code{nil}, @code{r} elements will be treated
just like @code{p} elements, unless the template command is given a
prefix (or a non-nil argument), in which case the template will be
inserted around the region. @xref{Elements}, for further information. If
this variable is non-@code{nil}, the behaviour is reversed.

In Transient Mark mode, this option is unused.
@end defopt


@node The mark list, The save list, Options, Top
@chapter The mark list

When a @code{p} or @code{r} element is inserted, or when
@code{tempo-interactive} is nil and a @code{(p @dots{})}, @code{(P
@dots{})} or @code{(r @dots{})} element is inserted, the current
position in the buffer is remembered for later. A mark is created and
stored in the variable @code{tepo-marks}.

There are two functions for moving between these marks.

@defun tempo-forward-mark
Move the point to the first mark on the mark list that is after the
point. If there is no such mark, nothing happens.
@end defun

@defun tempo-backward-mark
Move the point to the last mark on the mark lit that is before the
point. If there is no such mark, nothing happens.
@end defun

This function adds marks to the mark list.

@defun tempo-insert-mark mark
Inserts @var{mark} in the mark list, while keeping the list sorted. If
there already is a mark at the same position, only one mark is kept.
@end defun

@node The save list, Adding tempo, The mark list, Top
@chapter The save list

In a template, different elements can be saved for later with the
function @code{tempo-save-named} on a data structure called the
@dfn{save list}. The most obvious way to do this, is to supply a
@var{name} argument to the @code{(p @dots{})} element or one of its
likes, but it can also be done programmatically with an explicit call to
@code{tempo-save-named}.

@vindex tempo-named-insertions
Every saved element is saved in the list
@code{tempo-named-insertions}. After inserting a template, this list is
cleared, so things saved in it does not live between insertions. You
should use ordinary variables for that.

The following two functions could be used from inside a template.

@defun tempo-save-named name data
Save @var{data} on the save list under the name @var{name}. The function
returns nil.
@end defun

@defun tempo-lookup-named name
Lookup some saved data under the name @var{name}.  Returns the data if
@var{name} was found, and @code{nil} otherwise.
@end defun

The following functions deal with the save list, but should be
considered internal to tempo.

@defun tempo-insert-named name
Insert the previous insertion saved under a named specified in
@var{name}.  If there is no such name saved, a tempo mark is inserted.

Note that if the data is a string, it will not be run through the string
processor.
@end defun

@defun tempo-forget-insertions
Clears the save list.
@end defun

@node Adding tempo, Concept index, The save list, Top
@chapter Adding tempo support

@node Concept index, Function index, Adding tempo, Top
@chapter Concept index

@printindex cp

@node Function index, Variable index, Concept index, Top
@chapter Function index

@printindex fn

@node Variable index, Copying, Function index, Top
@chapter Variable index

@printindex vr

@node Copying,  , Variable index, Top
@chapter Copying

@contents
@bye
